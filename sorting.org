* Comparison Of Different Sorting Algorithms
| Algorithm      | Worst-case  | Average-case |
|----------------+-------------+--------------|
| Insertion Sort | \Theta(n^2)       | \Theta(n^2)        |
| Merge Sort     | \Theta(n\ln{n})  | \Theta(n\ln{n})   |
| Heapsort       | \Omicron(n\ln{n})  |              |
| Quick Sort     | \Theta(n^2)       | \Theta(n\ln{n})   |
| Counting Sort  | \Theta(k + n)    | \Theta(k + n)     |
| Radix Sort     | \Theta(d(k + n)) | \Theta(d(k + n))  |
| Bucket Sort    | \Theta(n^2)       | \Theta(n)         |

* Insertion Sort
- This is the basic version of insertion sort.
- Worst time: 
#+BEGIN_EXPORT latex 
\Theta(n^2) 
#+END_EXPORT
- Code
#+BEGIN_SRC clojure :results output
  (defn ins-sort [arr]
    (reduce (fn [res inp]
              (let [[less more] (split-with #(< % inp) res)]
                (concat less [inp] more)))
            []
            arr))

  (test-runner ins-sort)
#+END_SRC

#+RESULTS:
: true
: true

* Merge Sort
- Worst Time: 
#+BEGIN_EXPORT latex
\Theta(n\log{n})
#+END_EXPORT
- Code
#+BEGIN_SRC clojure :results output
  (defn merge-vec [[l & lrest :as left] [r & rrest :as right]]
    (if (and (not-empty left) (not-empty right))
      (if (> l r)
        (conj (merge-vec left rrest) r)
        (conj (merge-vec lrest right) l))
      (concat left right)))

  (defn merge-sort [arr]
    (if (<= (count arr) 1)
      arr
      (let [[left right] (split-at (quot (count arr) 2) arr)]
        (merge-vec (merge-sort left) (merge-sort right)))))

  (test-runner merge-sort)
#+END_SRC

#+RESULTS:
: true
: true

* Combine-sort
- A combination of insertion sort and merge sort
- Worst time: 
#+BEGIN_EXPORT latex
\Theta(nk + n\log(n/k))
#+END_EXPORT
- Code:
#+BEGIN_SRC clojure :results output
  (defn modified-divide [arr]
    (if (<= (count arr) 10)
      (ins-sort arr)
      (let [[left right] (split-at (quot (count arr) 2) arr)]
        (merge-vec (modified-divide left) (modified-divide right)))))

  (test-runner modified-divide)
#+END_SRC

#+RESULTS:
: true
: true

* Bubble Sort
- Another sorting algorithm
- Worst time: 
#+BEGIN_EXPORT latex
\Theta(n^2)
#+END_EXPORT
- Code:
#+BEGIN_SRC clojure :results output
  (defn bubble
    ([xs] (bubble xs [] false))
    ([[x y & xs] ys changed]
     (if (nil? y)
       [(conj ys x) changed]
       (if (> x y)
         (recur (cons x xs) (conj ys y) true)
         (recur (cons y xs) (conj ys x) changed)))))

  (defn bubble-sort [xs]
    (loop [[ys changed] (bubble xs)]
      (if changed
        (recur (bubble ys))
        ys)))

  (test-runner bubble-sort)
#+END_SRC

#+RESULTS:
: true
: true

* Heap Sort
- Worst Time: 
#+BEGIN_EXPORT latex
\Theta(n\log{n})
#+END_EXPORT
- Code
#+BEGIN_SRC clojure

#+END_SRC

* Tests
#+BEGIN_SRC clojure
  (def simple-list [2 4 6 1 3 7 2])
  (def complex-list (into [](take 100 (repeatedly #(rand-int 1000)))))

  (defn test-runner [func]
    (doseq [item [simple-list complex-list]]
      (println (= (sort item) (func item)))))
#+END_SRC

#+RESULTS:
: #'user/simple-list#'user/complex-list#'user/test-runner
