* Inversions
- For i < j : A[i] > A[j] is known as inversion.
** Solution
#+BEGIN_SRC clojure :results output
  (defn merge-vec [[l & lrest :as left] [r & rrest :as right]]
    (if (and (not-empty left) (not-empty right))
      (if (> l r)
        (let [[x inv] (merge-vec left rrest)]
          [(concat [r] x) (+ inv (count left))])
        (let [[x inv] (merge-vec lrest right)]
          [(concat [l] x) inv]))
      [(into [] (concat left right)) 0]))

  (defn merge-sort [arr inv]
    (if (<= (count arr) 1)
      [arr inv]
      (let [[left right] (split-at (quot (count arr) 2) arr) [l inl] (merge-sort left inv) [r inr] (merge-sort right inv)]
        (let [[x c] (merge-vec l r)]
          [x (+ c inl inr)]))))

  (test-runner merge-sort)
#+END_SRC

#+RESULTS:
: true

** Test
#+BEGIN_SRC clojure
  (def simple-test {:list [2 3 8 6 1] :ans 5})

  (defn test-runner [func]
    (doseq [x [simple-test]]
      (println (= (second (func (:list x) 0)) (:ans x)))))
#+END_SRC

#+RESULTS:
: #'user/simple-test#'user/test-runner

* Max Subarray
** Recursive
#+BEGIN_SRC clojure :results output
  (defn max-crossing-subarray
    ([left right] (let [l (max-crossing-subarray (reverse left)) r (max-crossing-subarray right)]
                    {:m-start (:m-pos l) :m-end (:m-pos r) :m-sum (+ (:m-sum l) (:m-sum r))}))
    ([arr]
     (reduce (fn [{m-sum :m-sum m-pos :m-pos c-sum :c-sum} {val :val pos :pos}]
               (let [n-sum (+ c-sum val)]
                 (if (>= n-sum m-sum)
                   {:m-pos pos :m-sum n-sum :c-sum n-sum}
                   {:m-pos m-pos :m-sum m-sum :c-sum n-sum})))
             {:m-pos (:pos (first arr)) :m-sum 0 :c-sum 0}
             arr)))

  (defn max-subarray
    ([arr] (max-subarray (map #(hash-map :val %1 :pos %2) arr (range (count arr))) nil))
    ([arr tip]
     (if (< (count arr) 2)
       (let [{pos :pos val :val} (first arr)]
         {:m-start pos :m-end pos :m-sum val})
       (let [[left right] (split-at (quot (count arr) 2) arr)
             l (max-subarray left tip) r (max-subarray right tip) c (max-crossing-subarray left right)]
         (last (sort-by :m-sum [l r c]))))))

  (test-runner max-subarray)
#+END_SRC

#+RESULTS:
: true

** Linear
#+BEGIN_SRC clojure :results output
  (defn max-subarray
    ([arr] (max-subarray (map #(hash-map :val %1 :pos %2) arr (range (count arr))) nil))
    ([xs tip]
     (reduce
      (fn [{c-sum :c-sum m-sum :m-sum c-start :c-start m-start :m-start m-end :m-end} {x :val pos :pos}]
        (let [n-sum (+ c-sum x)]
          (if (> n-sum m-sum)
            {:m-sum n-sum :c-sum n-sum :m-start c-start :m-end pos :c-start c-start}
            (if (< n-sum 0)
              {:m-sum m-sum :c-sum 0 :m-start m-start :m-end m-end :c-start (inc pos)}
              {:m-sum m-sum :c-sum n-sum :m-start m-start :m-end m-end :c-start c-start}))))
      {:m-sum 0 :c-sum 0 :m-start 0 :m-end 0 :c-start 0}
      xs)))

  (test-runner max-subarray)
#+END_SRC

#+RESULTS:
: true

** Test
#+BEGIN_SRC clojure
  (def simple-test {:list [13 -3 -25 20 -3 -16 -23 18 20 -7 12 -5 -22 15 -4 7] :ans [7 10]})

  (defn test-runner [func]
    (doseq [t [simple-test]]
      (let [res (func (:list t))]
        (println (= [(:m-start res) (:m-end res)] (:ans t))))))
#+END_SRC

#+RESULTS:
: #'user/simple-test#'user/test-runner
