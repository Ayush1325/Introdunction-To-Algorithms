* Dynamic Sets
- Basically all data structures like Heaps, Stacks etc are dynamic sets.
** Operations
*** Queries
- Simply return info about the set
**** Search(S, k)
**** Minimum(S)
**** Maximum(S)
**** Successor(S, x)
**** Predecessor(S, x)
*** Modifying Operations
- Change the set
**** Insert(S, x)
**** Delete(S, x)

* Heaps
** Priority Queues
- It is a data structure for maintaining a set S of elements, each with an associated value called key.
- Can be *max-priority-queue* or *min-priority-queue*.
*** Supports the following operations
**** Insert
#+begin_src rust
  fn max_heap_insert(arr: &mut Vec<i32>, key: i32) {
      arr.push(0);
      let x = arr.len();
      heap_increase_key(arr, x - 1, key);
  }
#+end_src
**** Maximum/Minimum
- Returns largest key.
#+begin_src rust
  fn heap_max(arr: &[i32]) -> i32 {
      ,*arr.first().expect("Heap Empty")
  }
#+end_src
**** Extract Max/Min
- Removes element with largest key.
#+begin_src rust
  fn extract_max(arr: &mut Vec<i32>) -> Result<i32, String> {
      if arr.is_empty() {
          return Err(String::from("Heap Underflow"));
      }
      let max = arr[0];
      arr[0] = *arr.last().expect("");
      arr.pop();
      let len = arr.len();
      max_heapify(arr, 0, len);
      Ok(max)
  }
#+end_src
**** Increase-Key/Decrease-Key
- Increases value of element x's key to the new value y which is assumed to be at lease as large as x's current key.
#+begin_src rust
  fn heap_increase_key(arr: &mut [i32], i: usize, key: i32) {
      let mut j = i;
      arr[j] = key;
      while j > 0 && arr[heap_opr::parent(j)] < arr[j] {
          arr.swap(heap_opr::parent(j), j);
          j = heap_opr::parent(j);
      }
  }
#+end_src
*** Uses
- Schedule jobs on a shared computer.

* Stacks
- Last-in First-out(LIFO)
- Can be implemented with normal arrays.
- Vectors can be operated as stacks, at least in rust. So don't see need to reimplement.
** Operations
*** Push
*** Pop
*** Empty
- Check if empty

* Queues
- First-in First-out(FIFO)
- Again, can be implemented with arrays. Not much reason to reimplement.
** Operations
*** Enqueue
- Insert to stack
*** Dequeue
- Delete from stack

* Linked List
- Its objects are arranged in linear order
- Each element contains pointers to other elements.
- Not always the most efficient dynamic set.
** Types
*** Single Linked
- Each element only points to the next element.
*** Double Linked
- Each elemet contains pointers to next and previous element.
*** Circular
- The last element points to the first element.
